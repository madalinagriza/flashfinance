---
timestamp: 'Thu Nov 06 2025 23:37:50 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251106_233750.a42d602e.md]]'
content_id: 16bec7c96c9918b8de6d0498402914e957961ba90d5a6bce9557fcc7b1f2a62a
---

# response:

The requests to `/Category/getCategoriesFromOwner` and `/Transaction/get_unlabeled_transactions` are timing out because the synchronizations designed to handle them are not firing.

## Why it's happening: Mismatch in `when` clause parameters

The core issue lies in a mismatch between the parameters present in the `Requesting.request` actions (as shown in your trace) and the parameters expected by the `when` clauses of your corresponding synchronizations.

Let's break it down:

1. **Incoming Request Trace:**
   Your trace shows the `Requesting.request` actions for the timing-out requests are structured as follows:
   ```
   Requesting.request { owner_id: '...', path: '/Category/getCategoriesFromOwner' } => { request: '...' }
   Requesting.request { owner_id: '...', path: '/Transaction/get_unlabeled_transactions' } => { request: '...' }
   ```
   Notice that these actions contain an `owner_id` parameter, but **do not contain a `session` parameter**. This indicates that the HTTP client making these requests is sending `owner_id` directly in the request body (e.g., `POST /api/Category/getCategoriesFromOwner` with body `{ "owner_id": "someUserId" }`).

2. **Synchronization `when` Clauses:**
   Now let's look at the `when` clauses for the relevant synchronizations:

   * For `/Category/getCategoriesFromOwner` (in `category.sync.ts`):
     ```typescript
     export const GetCategoriesFromOwnerRequest: Sync = ({ request, session, user, category_id, name, results }) => ({
       when: actions([Requesting.request, {
         path: "/Category/getCategoriesFromOwner",
         session, // Expects 'session'
       }, { request }]),
       // ...
     });
     ```
   * For `/Transaction/get_unlabeled_transactions` (in `transaction.sync.ts`):
     ```typescript
     export const GetUnlabeledTransactionsRequest: Sync = ({ request, session, user, tx_id, date, merchant_text, amount, status, results, error }) => ({
       when: actions([Requesting.request, {
         path: "/Transaction/getUnlabeledTransactions",
         session, // Expects 'session'
       }, { request }]),
       // ...
     });
     ```

3. **The Mismatch:**
   Both synchronizations explicitly require a `session` parameter in their `when` clauses to match the incoming `Requesting.request`. Since the actual `Requesting.request` actions contain `owner_id` but *lack* `session`, these `when` clauses never find a match.

   Consequently, the synchronizations never fire, no subsequent concept actions (like `Category.getCategoriesFromOwner` or `Transaction.get_unlabeled_transactions`) are triggered, and the HTTP requests eventually time out after 10000ms.

## Solution: Align HTTP Client Requests with Synchronization Expectations

To resolve this, you need to align the parameters sent by your HTTP client with what your synchronizations are designed to expect for authentication.

Given that your `where` clauses use `Sessioning._getUser` (which requires a `session` ID), the most consistent solution is to modify your HTTP client:

**Update your HTTP client to send a `session` ID in the request body for these endpoints, instead of `owner_id`.**

For example, if your client is currently sending a `POST` request to `/api/Category/getCategoriesFromOwner` with a body like:

```json
{
  "owner_id": "019a5974-cc78-7739-a34b-fe51150580d2"
}
```

You should change it to send:

```json
{
  "session": "019a5c89-1f12-7d84-b02d-289cce68b8ab"
}
```

(Using an actual valid session ID obtained from the login process).

This change will ensure that the `Requesting.request` actions generated by the engine have the `session` parameter, allowing your synchronizations to match correctly and execute their intended logic.
