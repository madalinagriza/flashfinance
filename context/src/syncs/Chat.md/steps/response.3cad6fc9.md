---
timestamp: 'Fri Nov 07 2025 04:17:50 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251107_041750.8b853d14.md]]'
content_id: 3cad6fc99b8783b0ad06539214c723acde6ffc86cae848204f4390e2e0b8da7e
---

# response:

Based on the provided files and the request log, the problem is a **path mismatch in the synchronization** which prevents the `GetTxInfoRequest` sync from triggering, ultimately causing the request to time out.

Here is a detailed breakdown of the issue:

### The Problem

The request to `/Transaction/get_tx_info` is timing out because the synchronization responsible for handling it, `GetTxInfoRequest` in `src/syncs/transaction.sync.ts`, is configured to listen for the wrong path.

1. **The Request Path:** The log shows the incoming request path is `'/Transaction/get_tx_info'` (snake\_case).
   ```
   Requesting.request {
     ...
     path: '/Transaction/get_tx_info'
   }
   ```
   This is the conventional path automatically generated by the `Requesting` concept's passthrough routing, which converts the camelCase method name `getTxInfo` from `TransactionConcept.ts` into snake\_case for the URL.

2. **The Synchronization Path:** The `GetTxInfoRequest` synchronization is pattern-matching against `"/Transaction/getTxInfo"` (camelCase).

   ```typescript
   // file: src\syncs\transaction.sync.ts

   export const GetTxInfoRequest: Sync = (/*...*/) => ({
     when: actions([Requesting.request, {
       path: "/Transaction/getTxInfo", // <--- PROBLEM HERE
       session,
       tx_id,
     }, { request }]),
     // ...
   });
   ```

Because `'get_tx_info'` does not match `'getTxInfo'`, the `when` clause of the synchronization is never satisfied. As a result, the sync's logic (including authentication and calling `Transaction.getTxInfo`) never runs, and crucially, the final `Requesting.respond` action is never called. The `Requesting` concept waits for this response until its 10000ms timeout is exceeded, at which point it logs the timeout error.

### The Solution

To fix this, you must update the `path` in the `GetTxInfoRequest` synchronization to use snake\_case, matching the actual request path.

**Modify `src/syncs/transaction.sync.ts`:**

```typescript
// file: src\syncs\transaction.sync.ts

//-- Get Transaction Info --//
export const GetTxInfoRequest: Sync = (
  { request, session, user, tx_id, txInfo, error },
) => ({
  when: actions([Requesting.request, {
    path: "/Transaction/get_tx_info", // CORRECTED: from getTxInfo to get_tx_info
    session,
    tx_id,
  }, { request }]),
  where: async (frames) => {
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user });

    // Handle unauthorized request
    if (frames.length === 0) {
      return new Frames({ ...originalFrame, [error]: "Unauthorized" });
    }

    // Query for the transaction info.
    const infoFrames = await frames.query(
      Transaction.getTxInfo,
      { owner_id: user, tx_id },
      { txInfo },
    );

    // Handle transaction not found
    if (
      infoFrames.length === 0 ||
      (infoFrames[0][txInfo] as unknown[]).length === 0
    ) {
      // CORRECTED: The error message was "Transaction not found", which is correct, but
      // the original implementation might have had a bug here. This looks okay.
      return new Frames({ ...originalFrame, [error]: "Transaction not found" });
    }

    // The result from the query (`txInfo`) is an array. We want to respond with the
    // single object inside it. We map the frame to replace the array with its first element.
    return infoFrames.map((frame) => {
      const infoArray = frame[txInfo] as any[];
      return {
        ...frame,
        [txInfo]: infoArray[0],
      };
    });
  },
  then: actions([Requesting.respond, { request, txInfo, error }]),
});
```

By making this change, the synchronization will correctly match the incoming request, execute its logic, and fire the `Requesting.respond` action, preventing the timeout.
